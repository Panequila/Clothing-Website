*Strict Mode makes react(v18) double render everything so that it catches any weird behaviour (errors) in the app.
*It is expensive (optimization-wise) to make changes to the Real Dom, it's easier to make these changes in JS
*unmounting removes things from the DOM.
*react makes changes to the Virtual DOM which then changes the Real DOM.  
*JSX is a JS extension which stands for (JS XML),
	it allows us to write HTML in React. JSX makes it easier to write and add HTML in React.
*React Library is the engine, determines what to render and how,
	while React DOM determines what we are trying to render to and that is the DOM of the browser. 

//this.state.name = 'Ramez' this won't work because it changes the same object
              //this.setStatename: 'Ramez'; //in order for react to rerender, it has to create another object
              //and update it with these values like the line above in which we used setState.
              //running the setState with a call back function "console.log", which runs after the setState
*we use "key" value in map() so that when we add an element to the array it doesn't rerender the whole array
and instead renders the new element only.
*The Component is mainly considered with when to render or rerender, it is meant to tie together functionality and visual representation of the UI.
*The Component helps us create reusable code.
*componentDidMount() (a life cycle method) is called the first time react renders a component onto the page, use it when making API requests.
*Java Promises > Revise later
*In React, the constructor() runs first (in which we initialize the state), then the render() (determines what to show),
then componentDidMount().
*The html tags inside the .js are actually components that react included which simulates and input html tag when rendered,
 the reason for this is to bind functinality with the UI and that's the whole point of React.
*JSX is a syntax extension of JS, we use <div className> instead of <div class> because react allows us to create classes in JS,
so we used JSX to change the syntax.
*JS is locally scoped, you can't use its variables outside of where they are called
*An Anonymous function in JS is not stored anywhere, which means this function is initalized everytime you use it (in render())
 which is not optimal. That's why we should create the functions in our Component Class so that they get initalized one time only.
*you can not have a component return multiple html-like components like (div,h1) at the same level, it must return one parent only which
can have children
*Props stand for properties, they are identical to different properties that we use in other components for ex. <input className="search-box" type="search" />
 className and type are properties
*Components will rerender whenever props change or is different, just like when setState is called

CSS:
*CSS files are applied to the entire app, imports aren't really necessary meaning any other component can access the css file without importing it
but we use them however cause it's easier for the devs.
//by using string interpolation " ` " we give a base/general styling for the search box,
 and the option for specific styling which will override the base 
        className={`search-box ${this.props.className}`}
*String interpolation allows us to write JS inside of html

Class Vs Functional Components:
*rendering in class comp only executes the render() method, while in the func component it executes the whole component
*setState is a method that's unique to class Components
*functional components utilize hooks to render our app
*there are no lifecycles in functional components
*pure functions return the same output no matter how many times it's called when given the same arguments unlike impure functions.
a side effect is when a function creates some kind of effect outside of its scope, like setting a variable outside of function.
*in react we use hooks like "useState("initial value of the variable")" to write impure functions
*useState gives the const variable back two parameters(value, setValue),
	each hook updates only 1 value unlike setState where we can update multiple values.
*functional components run from top to bottom
*useEffect Hook takes two arguments, the call-back function and an array of dependecies (stateValues or propValues),
	whenever these values change, the call-back function gets calle,
	we leave the array empty so that we call it once only when the app mounts to fetch the users and that's it.

SASS is much more effecient way of writing css